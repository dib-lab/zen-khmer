<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Exploring graphs and graph structure &mdash; zaok 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="zaok 0.1 documentation" href="index.html" />
    <link rel="next" title="Summarizing the basics" href="summarizing-khmer-basics.html" />
    <link rel="prev" title="Manipulating k-mer abundance spectra" href="manipulating-histograms.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>zaok 0.1 documentation</span></a></h1>
        <h2 class="heading"><span>Exploring graphs and graph structure</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="manipulating-histograms.html">Manipulating k-mer abundance spectra</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="summarizing-khmer-basics.html">Summarizing the basics</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput,
div.nbinput > div,
div.nbinput div[class^=highlight],
div.nbinput div[class^=highlight] pre,
div.nboutput,
div.nboutput > div,
div.nboutput div[class^=highlight],
div.nboutput div[class^=highlight] pre {
    background: none;
    border: none;
    padding: 0 0;
    margin: 0;
    box-shadow: none;
}

/* avoid gaps between output lines */
div.nboutput div[class^=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput,
div.nboutput {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
}

/* input container */
div.nbinput {
    padding-top: 5px;
}

/* last container */
div.nblast {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput > :first-child pre {
    color: #303F9F;
}

/* output prompt */
div.nboutput > :first-child pre {
    color: #D84315;
}

/* all prompts */
div.nbinput > :first-child[class^=highlight],
div.nboutput > :first-child[class^=highlight],
div.nboutput > :first-child {
    min-width: 11ex;
    padding-top: 0.4em;
    padding-right: 0.4em;
    text-align: right;
    flex: 0;
}

/* input/output area */
div.nbinput > :nth-child(2)[class^=highlight],
div.nboutput > :nth-child(2),
div.nboutput > :nth-child(2)[class^=highlight] {
    padding: 0.4em;
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}

/* input area */
div.nbinput > :nth-child(2)[class^=highlight] {
    border: 1px solid #cfcfcf;
    border-radius: 2px;
    background: #f7f7f7;
}

/* override MathJax center alignment in output cells */
div.nboutput div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.pngmath center alignment in output cells */
div.nboutput div.math p {
    text-align: left;
}

/* standard error */
div.nboutput  > :nth-child(2).stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-bold { font-weight: bold; }
</style>
<div class="nbinput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [1]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">khmer</span>
</pre></div>
</div>
</div>
<div class="section" id="Exploring-graphs-and-graph-structure">
<h1>Exploring graphs and graph structure<a class="headerlink" href="#Exploring-graphs-and-graph-structure" title="Permalink to this headline">¶</a></h1>
<p>Graphs can be a tremendously powerful way to look at sequencing data,
but unlike k-mers, operating on graphs can be very computationally
expensive. This is largely because of combinatorics: for example, forks
and loops in the graph make simple traversal expensive. Some of khmer&#8217;s
functionality is aimed at simplifying, or at least making possible, some
basic traversal approaches.</p>
<div class="section" id="Some-basic-traversal-functions.">
<h2>Some basic traversal functions.<a class="headerlink" href="#Some-basic-traversal-functions." title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s start with some initial code that builds us a linear path in a
graph:</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [2]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">21</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">khmer</span><span class="o">.</span><span class="n">Countgraph</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="mi">1</span><span class="n">e6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">seq</span> <span class="o">=</span> <span class="s1">&#39;CCCTGTTAGCTACGTCCGTCTAAGGATATTAACATAGTTGCGACTGCGTCCTGTGCTCA&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>Out[2]:
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>
<span></span>39
</pre></div>
</div>
</div>
<p>In general, we use reads or sequences as an index into the De Bruijn
graph, and most of the graph functions take either a k-mer or a sequence
as input.</p>
<p>For example, if you wanted to get the degree (number of neighbors) for
each k-mer in that sequence, you could ask:</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [3]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
<span class="o">...</span>    <span class="n">kmer</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">K</span><span class="p">]</span>
<span class="o">...</span>    <span class="nb">print</span><span class="p">(</span><span class="n">ng</span><span class="o">.</span><span class="n">kmer_degree</span><span class="p">(</span><span class="n">kmer</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="container">
</div>
<div class="container">
<div class="highlight"><pre>
1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1
</pre></div></div>
</div>
<p>This tells you that the sequence is linear and disconnected - no node
has more than two neighbors, and the end nodes have one neighbor.</p>
<div class="section" id="Question:">
<h3>Question:<a class="headerlink" href="#Question:" title="Permalink to this headline">¶</a></h3>
<p>How would you introduce a higher-degree node into this graph?</p>
<p>You can also ask for the identity of the neighbors for each k-mer with
the function &#8216;ng.neighbors(kmer)&#8217;.</p>
<p>We don&#8217;t actually do too much exploration of graphs at the Python level,
because, well, for large data sets it&#8217;s slow.</p>
<p>Instead, we provide a few slightly higher level functions, such as
<code class="docutils literal"><span class="pre">calc_connected_graph_size</span></code>, which tells you how many k-mers connect
to the seed kmer in the graph:</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [4]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">calc_connected_graph_size</span><span class="p">(</span><span class="n">seq</span><span class="p">[:</span><span class="n">K</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>Out[4]:
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>
<span></span>39
</pre></div>
</div>
</div>
<p>Keep in mind that for really large graphs, this may take a really,
really long time to run.</p>
</div>
<div class="section" id="Question:">
<h3>Question:<a class="headerlink" href="#Question:" title="Permalink to this headline">¶</a></h3>
<p>How would you increase the size of the connected graph?</p>
</div>
</div>
<div class="section" id="Building-waypoints-in-De-Bruijn-graphs">
<h2>Building waypoints in De Bruijn graphs<a class="headerlink" href="#Building-waypoints-in-De-Bruijn-graphs" title="Permalink to this headline">¶</a></h2>
<p>Sometimes we have to deal with extremely large graphs.</p>
<p>khmer provides a technique called &#8216;tagging&#8217;, in which a subset of k-mers
in the graph are chosen as representatives of the whole graph - and we
choose these representatives so that <em>every</em> k-mer in the entire graph
is within distance D of at least one representative.</p>
<p>(khmer does this by using the reads as a guide into the graph;khmer
makes sure that each read has a tag every D k-mers, and, since the graph
is entirely constructed from reads, then the graph ends up being tagged
at distance D as well.)</p>
<p>Tagging has a few nice features:</p>
<ul class="simple">
<li>there are many fewer tags than there are k-mers (2D fold fewer,
approximately.)</li>
<li>the structure and connectivity of the tags serves as a good proxy for
the connectivity of the overall graph; in this way they serve as a
sort of sparse graph.</li>
<li>tags are somewhat refractory to coverage: highly covered regions will
get many fewer tags than the number of reads from that region.</li>
<li>tags provide a good entry point into the graph for traversal; in
essense, they provide waypoints for other work.</li>
<li>tags could, in theory, be used as an index into the reads. (&#64;CTB
expand.)</li>
</ul>
<p>Graph theory friends tell me that this is actually a D-dominating set,
and we&#8217;ll revisit this concept later on (c.f. spacegraphcats).</p>
<blockquote>
<div><p>Right now we don&#8217;t do a very efficient job of creating the tags. I
have a few ideas for improving this using streaming approaches.</p>
<p>Our tag data structure implementation is pretty bad - we use an STL
set to store the tags...</p>
</div></blockquote>
<p>To make use of tags, the tags need to be built first. Here&#8217;s an example.</p>
<p>First, construct a Nodegraph:</p>
<div class="nbinput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [5]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">21</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">khmer</span><span class="o">.</span><span class="n">Nodegraph</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="mi">1</span><span class="n">e6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Create a sequence longer than K:</p>
<div class="nbinput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [6]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">seq</span> <span class="o">=</span> <span class="s1">&#39;CCCTGTTAGCTACGTCCGTCTAAGGATATTAACATAGTTGCGACTGCGTCCTGTGCTCA&#39;</span>
</pre></div>
</div>
</div>
<p>Now, instead of adding it to <code class="docutils literal"><span class="pre">ng</span></code> with <code class="docutils literal"><span class="pre">consume</span></code>, use
<code class="docutils literal"><span class="pre">consume_and_tag</span></code>:</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [7]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">consume_and_tag</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>Out[7]:
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>
<span></span>39
</pre></div>
</div>
</div>
<p>You can now look at the tags with <code class="docutils literal"><span class="pre">get_tags_and_positions</span></code>:</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [8]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">get_tags_and_positions</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>Out[8]:
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>
<span></span>[(19, 156582046028), (39, 1984875433400)]
</pre></div>
</div>
</div>
<p>Here, the first element of each tuple is the position of the tag within
the sequence, and the second element is the actual tag &#8211; you can
convert those back into DNA with <code class="docutils literal"><span class="pre">reverse_hash</span></code>:</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [9]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ng</span><span class="o">.</span><span class="n">get_tags_and_positions</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">reverse_hash</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>Out[9]:
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>
<span></span>&#39;AACTATGTTAATATCCTTAGA&#39;
</pre></div>
</div>
</div>
<p>Points to make:</p>
<ul class="simple">
<li>you can use any query sequence you want, not just the one you used to
create the tags ;).</li>
<li>the tagging distance D is 40 by default, and can be adjusted with
<code class="docutils literal"><span class="pre">_set_tag_density</span></code>.</li>
</ul>
</div>
<div class="section" id="Partitioning">
<h2>Partitioning<a class="headerlink" href="#Partitioning" title="Permalink to this headline">¶</a></h2>
<p>The motivation behind tags came from a desire to <em>partition</em> data sets:
back when, our intution was that metagenome data sets should split up
into disconnected components based on their origin species. (You can
read more in <a class="reference external" href="http://www.pnas.org/content/109/33/13272.abstract">Pell et al.,
2012</a>.)</p>
<p>This is challenging because you essentially want an all-by-all
connectivity map for the graph - you want to know, does read A connect
(transitively) to read Z, by any path, and you want to know this for all
the reads in the data set. This is hard!</p>
<p>We initially developed tagging for the purpose of partitioning, and we
do the following:</p>
<ul class="simple">
<li>tag the graph systematically (as explained above);</li>
<li>explore to a distance D from each tag, and identify all neighboring
tags within distance D;</li>
<li>assign partition IDs to each set of connected tags;</li>
<li>split the reads up based on their partition IDs.</li>
</ul>
<p>This does work, mostly, and it turns out to split the graph up into bins
that group reads by species. (See <a class="reference external" href="http://www.pnas.org/content/111/13/4904">Howe et al.,
2014</a>.)</p>
<p>For an example of partitioning, let&#8217;s construct an artifical sequence.</p>
<div class="nbinput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [10]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">longseq</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;AGGAGGAGCATTTGTGCGATGCCCTATGGGGAGACCTATCTGCCGGGGAAATGCGCACA&quot;</span><span class="p">,</span>
<span class="o">...</span>    <span class="s2">&quot;TAACATAATCTAATCTACCACATTATGAACCCCCAGTGGGCACGTGTTCATTGCGTACGATCGCATTC&quot;</span><span class="p">,</span>
<span class="o">...</span>    <span class="s2">&quot;TACTTGATTCCCGCAGTGGTACGACGCTATGTA&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">longseq</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">longseq</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>If we break this 160-bp sequence up into three bits,</p>
<div class="nbinput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [11]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">longseq</span><span class="p">[:</span><span class="mi">70</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">longseq</span><span class="p">[</span><span class="mi">40</span><span class="p">:</span><span class="mi">120</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">end</span> <span class="o">=</span> <span class="n">longseq</span><span class="p">[</span><span class="mi">90</span><span class="p">:]</span>
</pre></div>
</div>
</div>
<p>we can see that <code class="docutils literal"><span class="pre">begin</span></code> and <code class="docutils literal"><span class="pre">end</span></code> shouldn&#8217;t connect without
<code class="docutils literal"><span class="pre">middle</span></code>. Let&#8217;s see if partitioning agrees!</p>
<p>First, let&#8217;s build a graph and then add the beginning and end bits:</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [12]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">21</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">khmer</span><span class="o">.</span><span class="n">Nodegraph</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="mi">1</span><span class="n">e6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">consume_and_tag</span><span class="p">(</span><span class="n">begin</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">consume_and_tag</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>Out[12]:
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>
<span></span>50
</pre></div>
</div>
</div>
<p>Now, run the partitioning code, get back a partition object, and ask for
a partition count:</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [13]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ng</span><span class="o">.</span><span class="n">do_subset_partition</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n_partitions</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">count_partitions</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">n_partitions</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="container">
</div>
<div class="container">
<div class="highlight"><pre>
2
</pre></div></div>
</div>
<p>Yep - 2 partitions!</p>
<p>Now let&#8217;s add the middle bit, which will connect the two isolated
partitions:</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [14]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">consume_and_tag</span><span class="p">(</span><span class="n">middle</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>Out[14]:
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>
<span></span>40
</pre></div>
</div>
</div>
<p>If we redo the partitioning, we should now get 1 partition:</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [15]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ng</span><span class="o">.</span><span class="n">do_subset_partition</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">n_partitions</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">count_partitions</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">n_partitions</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="container">
</div>
<div class="container">
<div class="highlight"><pre>
1
</pre></div></div>
</div>
<p>...and we do!</p>
<p>Partitioning hasn&#8217;t, in the end, proven to be that useful in practice
(<a class="reference external" href="http://ivory.idyll.org/blog/2016-partitioning-no-more.html">also see blog
post</a>).
The downsides of the approach are:</p>
<ul class="simple">
<li>it turns out that any source of systematic bias in sequencing will
result in a completely connected graph (<a class="reference external" href="https://arxiv.org/abs/1212.0159">Howe et al.,
2012</a>; such biases are common.</li>
<li>it also turns out that most metagenome graphs are, in reality,
completely connected.</li>
</ul>
<p>However, tags are still potentially useful for other things than
straight up partitioning.</p>
<p>Camille Scott extended tagging with <em>labels</em> - the idea is that each tag
can be labelled with 1 or more arbitrary identifiers. This lets you do
things like build colored De Bruijn graphs, equiv. do pangenome
analysis.</p>
<p>References:</p>
<p><a class="reference external" href="http://ivory.idyll.org/blog/2015-wok-labelhash.html">http://ivory.idyll.org/blog/2015-wok-labelhash.html</a></p>
<p><a class="reference external" href="https://github.com/dib-lab/2015-khmer-wok4-multimap/blob/master/do-counting.py">https://github.com/dib-lab/2015-khmer-wok4-multimap/blob/master/do-counting.py</a></p>
<p>For an example, let&#8217;s take the sequence we used in partitioning, and add
labels &#8211; here, &#8216;1&#8217; and &#8216;2&#8217;.</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [16]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">21</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">khmer</span><span class="o">.</span><span class="n">Nodegraph</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="mi">1</span><span class="n">e6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lh</span> <span class="o">=</span> <span class="n">khmer</span><span class="o">.</span><span class="n">_GraphLabels</span><span class="p">(</span><span class="n">ng</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lh</span><span class="o">.</span><span class="n">consume_sequence_and_tag_with_labels</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lh</span><span class="o">.</span><span class="n">consume_sequence_and_tag_with_labels</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>Out[16]:
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>
<span></span>50
</pre></div>
</div>
</div>
<p>We can now ask for labels by overlap with <code class="docutils literal"><span class="pre">longseq</span></code>:</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [17]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">tags</span> <span class="o">=</span> <span class="n">ng</span><span class="o">.</span><span class="n">get_tags_and_positions</span><span class="p">(</span><span class="n">longseq</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">:</span>
<span class="o">...</span>    <span class="nb">print</span><span class="p">(</span><span class="n">lh</span><span class="o">.</span><span class="n">get_tag_labels</span><span class="p">(</span><span class="n">tag</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="container">
</div>
<div class="container">
<div class="highlight"><pre>
[1]
[1]
[2]
[2]
</pre></div></div>
</div>
<p>This lets us add arbitrary information to the graph by indexing using
the tags or the labels.</p>
<p>One particular use case for this is comparing several different data
sets by looking at how the graphs overlap, or do not. This is explored a
bit in <a class="reference external" href="http://ivory.idyll.org/blog/2015-wok-evaluate.html">a blog
post</a>.</p>
<p>We&#8217;ll show another prototype use case belong, for labeling longer paths
for use in assembly.</p>
<p>De Bruijn graphs themselves are often quite large, because they have as
many nodes in them as there are unique k-mers in the data set. Many of
these k-mers may be collapsable into linear paths. The result of doing
this graph contraction is called a &#8220;compact De Bruijn graph&#8221;, and we
have some functionality for building them in khmer.</p>
<p>This functionality consists of two functions on graphs:
<code class="docutils literal"><span class="pre">find_high_degree_nodes</span></code> and <code class="docutils literal"><span class="pre">traverse_and_mark_linear_paths</span></code>.</p>
<p>There&#8217;s a script
<a class="reference external" href="https://github.com/dib-lab/khmer/blob/zaok/sandbox/extract-compact-dbg.py">sandbox/extract-compact-dbg.py</a>
that you can use with genomes or reads. For this, you&#8217;ll need a copy of
the script from khmer&#8217;s sandbox directory &#8211;</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [18]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="o">!</span>curl -L -O https://github.com/dib-lab/khmer/raw/zaok/sandbox/extract-compact-dbg.py
<span class="o">&gt;&gt;&gt;</span> <span class="o">!</span>curl -L -O https://github.com/dib-lab/khmer/raw/zaok/sandbox/graph_writer.py

<span class="o">&gt;&gt;&gt;</span> <span class="o">!</span>chmod +x extract-compact-dbg.py
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="container">
</div>
<div class="container">
<div class="highlight"><pre>
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   149  100   149    0     0    155      0 --:--:-- --:--:-- --:--:--   155
100  5697  100  5697    0     0   3358      0  0:00:01  0:00:01 --:--:-- 11918
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   142  100   142    0     0    194      0 --:--:-- --:--:-- --:--:--   194
100  2546  100  2546    0     0   2663      0 --:--:-- --:--:-- --:--:--  2663
</pre></div></div>
</div>
<p>This script produces GML files that can be viewed with
<a class="reference external" href="https://gephi.org/">Gephi</a>.</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [19]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="o">!</span>./extract-compact-dbg.py -x 1e6 data/genome.fa.gz -o genome.gml
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="container">
</div>
<div class="container">
<div class="highlight"><pre>
building graphs and loading files
finding high degree nodes
traversing linear segments from 4 nodes
... 0 of 4
13 segments, containing 10094 nodes
saving to genome.gml
</pre></div></div>
</div>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [20]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="o">!</span>./extract-compact-dbg.py -x 1e8 data/reads.fa.gz -o reads.gml
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="container">
</div>
<div class="container">
<div class="highlight"><pre>
building graphs and loading files
... data/reads.fa.gz 10000
... data/reads.fa.gz 20000
finding high degree nodes
...2 data/reads.fa.gz 10000
...2 data/reads.fa.gz 20000
traversing linear segments from 16554 nodes
... 0 of 16554
... 10000 of 16554
29382 segments, containing 737769 nodes
saving to reads.gml
</pre></div></div>
</div>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [21]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="o">!</span>./extract-compact-dbg.py -x 1e6 data/mixed-species.fa.gz -o mixed.gml
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="container">
</div>
<div class="container">
<div class="highlight"><pre>
building graphs and loading files
finding high degree nodes
traversing linear segments from 3 nodes
... 0 of 3
11 segments, containing 10033 nodes
saving to mixed.gml
</pre></div></div>
</div>
</div>
<div class="section" id="Visualizing-compact-De-Bruijn-graphs-with-Gephi">
<h2>Visualizing compact De Bruijn graphs with Gephi<a class="headerlink" href="#Visualizing-compact-De-Bruijn-graphs-with-Gephi" title="Permalink to this headline">¶</a></h2>
<p>(Gephi demo here)</p>
</div>
<div class="section" id="Assembling-linear-sequences">
<h2>Assembling linear sequences<a class="headerlink" href="#Assembling-linear-sequences" title="Permalink to this headline">¶</a></h2>
<p>For a long time, we avoided anything that smacked of actual assembly.
But, well, inspired by the compact DBG stuff, we recently added some
assembly functionality &#8211; you&#8217;ve already seen one of the functions:</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [22]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">input_seq</span> <span class="o">=</span> <span class="s2">&quot;TGAGCACAGGACGCAGTCGCAACTATGTTAATATCCTTAGACGGACGTAGCTAACAGGG&quot;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">khmer</span><span class="o">.</span><span class="n">Nodegraph</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">1</span><span class="n">e6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="n">input_seq</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">assemble_linear_path</span><span class="p">(</span><span class="s1">&#39;AGACGGACGTAGCTAACAGGG&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>Out[22]:
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>
<span></span>&#39;TGAGCACAGGACGCAGTCGCAACTATGTTAATATCCTTAGACGGACGTAGCTAACAGGG&#39;
</pre></div>
</div>
</div>
<p>but this only works on linear segments of graphs &#8211; for example, if we
add a neighbor in the middle, it confounds the graph and you get a short
assembly:</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [23]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="s1">&#39;G&#39;</span> <span class="o">+</span> <span class="n">input_seq</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">30</span><span class="o">+</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">assemble_linear_path</span><span class="p">(</span><span class="s1">&#39;AGACGGACGTAGCTAACAGGG&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>Out[23]:
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>
<span></span>&#39;ATATCCTTAGACGGACGTAGCTAACAGGG&#39;
</pre></div>
</div>
</div>
<p>There are several ways to handle this, but they all require simplifying
the graph (by trimming errors, or finding short branches, or what have
you). However you decide to simplify the graph, you can delete nodes by
creating a &#8220;stopgraph&#8221; and passing that in - this tells the assembly
function to ignore that node completely.</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [24]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">stopgraph</span> <span class="o">=</span> <span class="n">khmer</span><span class="o">.</span><span class="n">Nodegraph</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">1</span><span class="n">e6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">stopgraph</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="s1">&#39;G&#39;</span> <span class="o">+</span> <span class="n">input_seq</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">30</span><span class="o">+</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">assemble_linear_path</span><span class="p">(</span><span class="s1">&#39;AGACGGACGTAGCTAACAGGG&#39;</span><span class="p">,</span> <span class="n">stopgraph</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>Out[24]:
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>
<span></span>&#39;TGAGCACAGGACGCAGTCGCAACTATGTTAATATCCTTAGACGGACGTAGCTAACAGGG&#39;
</pre></div>
</div>
</div>
</div>
<div class="section" id="Assembling-across-high-degree-nodes-with-labeled-paths">
<h2>Assembling across high-degree nodes with labeled paths<a class="headerlink" href="#Assembling-across-high-degree-nodes-with-labeled-paths" title="Permalink to this headline">¶</a></h2>
<p>You can also use labels to identify situations where you have evidence
for crossing a branch point. For example,</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [25]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">input_seq</span> <span class="o">=</span> <span class="s2">&quot;TGAGCACAGGACGCAGTCGCAACTATGTTAATATCCTTAGACGGACGTAGCTAACAGGG&quot;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span> <span class="o">=</span> <span class="n">khmer</span><span class="o">.</span><span class="n">Nodegraph</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">1</span><span class="n">e6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="n">input_seq</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ng</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="s1">&#39;G&#39;</span> <span class="o">+</span> <span class="n">input_seq</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">30</span><span class="o">+</span><span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>Out[25]:
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>
<span></span>1
</pre></div>
</div>
</div>
<p>First, find high degree nodes:</p>
<div class="nbinput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [26]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">hdn</span> <span class="o">=</span> <span class="n">ng</span><span class="o">.</span><span class="n">find_high_degree_nodes</span><span class="p">(</span><span class="n">input_seq</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Then, use labels to build paths across high degree nodes:</p>
<div class="nbinput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [27]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">lh</span> <span class="o">=</span> <span class="n">khmer</span><span class="o">.</span><span class="n">_GraphLabels</span><span class="p">(</span><span class="n">ng</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">lh</span><span class="o">.</span><span class="n">label_across_high_degree_nodes</span><span class="p">(</span><span class="n">input_seq</span><span class="p">,</span> <span class="n">hdn</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

</pre></div>
</div>
</div>
<p>And then assemble using the labels:</p>
<div class="nbinput container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>In [28]:
</pre></div>
</div>
<div class="highlight-ipython3"><div class="highlight"><pre>
<span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">lh</span><span class="o">.</span><span class="n">assemble_labeled_path</span><span class="p">(</span><span class="s1">&#39;AGACGGACGTAGCTAACAGGG&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast container">
<div class="highlight-none"><div class="highlight"><pre>
<span></span>Out[28]:
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>
<span></span>[&#39;TGAGCACAGGACGCAGTCGCAACTATGTTAATATCCTTAGACGGACGTAGCTAACAGGG&#39;]
</pre></div>
</div>
</div>
<p>Next: <a class="reference external" href="summarizing-khmer-basics.html">Summarizing the basics</a></p>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="manipulating-histograms.html">Manipulating k-mer abundance spectra</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="summarizing-khmer-basics.html">Summarizing the basics</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, C. Titus Brown.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
  </body>
</html>